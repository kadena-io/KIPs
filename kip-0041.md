---
KIP: '0041'
Title: kadena_connect_v1 API
Author: Danillo Felixdaal and Bart Huijgen
Status: Draft
Type: Standard
Category: Interface
Created: 2025-02-17
---

# kadena_connect_v1 API

## Abstract

This KIP standardizes the `kadena_connect_v1` method for establishing a connection between decentralized applications (dApps) and Kadena wallets. The method handles user authorization—including domain whitelisting—and returns active account and network information, providing a consistent interface for wallet connectivity across the Kadena ecosystem. dApps are assumed to be operating on a specific network; if the network changes, the dApp will reconnect for that specific network.

## Motivation

Inconsistent connection methods across various wallet implementations lead to fragmented user experiences and increased integration complexity for dApps. Standardizing `kadena_connect_v1` will:

- Unify connection workflows across all Kadena wallets.
- Simplify dApp integration with predictable method signatures.
- Enable silent reconnection for returning users, while allowing wallets to whitelist certain domains for added security.
- Emphasize that the wallet returns a single network (not an array), since the dApp is operating on a specific network; if the network changes, the dApp will reconnect for that specific network.

## Specification

### Method Definition

**Method Name:** `kadena_connect_v1`

### Request Parameters

```typescript
interface ConnectRequest {
  silent?: boolean // Optional: Attempt silent authentication without UI prompts.
  networkId: string // Required: Network ID (e.g., "mainnet01", "testnet04").
  // permissions?: string[]    // Optional (future consideration): Permissions such as "read-data", "sign", "coin-type", etc.
}
```

### Response

The method returns a ConnectResponse object containing both network and account details:

```typescript
interface ConnectResponse {
  networkInfo: NetworkInfo
  account: AccountInfo
}

interface NetworkInfo {
  name: string // The human-readable name of the network (e.g., "Mainnet").
  networkId: string // The unique identifier for the network (e.g., "mainnet01").
  url?: string | string[] // Optional: The network endpoint URL, or a list of URLs if multiple nodes are available.
}

interface AccountInfo {
  accountName: string // The unique identifier for the account.
  fungibleContract: string // Identifier for the fungible token contract.
  chainAccounts?: Array<{
    chainId: string // The chain identifier within the network.
    guard: {
      keys: string[] // Array of public keys (secret keys are omitted for security).
      pred: string // Predicate defining key validation (e.g., "keys-all", "keys-any").
    }
  }>
}
```

### Error Responses

In case of failure, the wallet **MUST** return an error according to the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#error_object):

```typescript
interface ErrorResponse {
  id: number
  jsonrpc: '2.0'
  error: {
    code: number
    message: string
    data?: object
  }
}
```

#### Error Types

- -32002: Resource unavailable
- -32004: Requested network does not exist
- -32005: Could not return account information
- -32006: User rejected connection request
- -32007: Silent mode not permitted
- -32602: Invalid method parameter(s)
- -32603: Internal server error

### Behavior Requirements

- **User Consent:**
  - **MUST** display connection details (including the requesting dApp’s domain) unless `silent: true` is specified and prior consent exists.
  - **MUST** persist consent only after explicit user approval.
- **Network Handling:**
  - **MUST** validate the provided networkId against supported networks.
  - **MUST** return a `Requested network does not exist` error if the network is invalid.
- **Permission Handling (Future Iterations):**
  - The wallet may consider a `permissions` field to reject requests that exceed allowed scopes.
- **Cryptographic Safety:**
  - **MUST NOT** expose secret keys.
  - **MUST** return public keys in a secure, standardized format.

## Examples

### Basic Connection Request

#### Request

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "kadena_connect_v1",
  "params": {
    "networkId": "mainnet01"
  }
}
```

#### Success Response (Single Node)

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "networkInfo": {
      "name": "Mainnet",
      "networkId": "mainnet01",
      "url": "https://api.chainweb.com"
    },
    "account": {
      "accountName": "k:ae18efd...",
      "fungibleContract": "coin",
      "chainAccounts": [
        {
          "chainId": "0",
          "guard": {
            "keys": [
              "ae18efd16cbd49e9a92552a2589ac01491b486fbcbb1e3f07980f945597e2033"
            ],
            "pred": "keys-all"
          }
        }
      ]
    }
  }
}
```

### Silent Reconnection Attempt

#### Request

```json
{
  "id": 2,
  "jsonrpc": "2.0",
  "method": "kadena_connect_v1",
  "params": {
    "silent": true,
    "networkId": "testnet04"
  }
}
```

#### Error Response (if Silent Mode is Not Permitted)

```json
{
  "id": 2,
  "jsonrpc": "2.0",
  "error": {
    "code": -32007,
    "message": "Silent mode not permitted"
  }
}
```

#### Error Response (if User Rejects Connection)

```json
{
  "id": 2,
  "jsonrpc": "2.0",
  "error": {
    "code": -32006,
    "message": "User rejected connection request"
  }
}
```

### Error Response for Unsupported Network

```json
{
  "id": 3,
  "jsonrpc": "2.0",
  "error": {
    "code": -32004,
    "message": "Requested network does not exist"
  }
}
```

### Success Response with Multiple Nodes

```json
{
  "id": 4,
  "jsonrpc": "2.0",
  "result": {
    "networkInfo": {
      "name": "testnet",
      "networkId": "testnet04",
      "url": ["https://api.chainweb.com", "https://api.chainweb.com"]
    },
    "account": {
      "accountName": "k:def456...",
      "fungibleContract": "coin",
      "chainAccounts": [
        {
          "chainId": "1",
          "guard": {
            "keys": [
              "def4562d858cd2380b5e2b654e58035f7189a6e8158686a1bb7eabb585a56e7f"
            ],
            "pred": "keys-all"
          }
        }
      ]
    }
  }
}
```

## WalletConnect Integration Considerations

WalletConnect establishes secure sessions through its own pairing and settlement process as defined in [KIP-0017](https://github.com/kadena-io/KIPs/blob/master/kip-0017.md). For wallets that use WalletConnect:

- **Separation of Concerns:**  
  The initial pairing, secure channel establishment, and session negotiation are managed entirely by WalletConnect. Therefore, `kadena_connect_v1` is not used to perform the primary connection handshake.

- **Post-Pairing Handshake:**  
  Once a WalletConnect session is established, the dApp should call `kadena_connect_v1` to retrieve the active network and account information for the specific network on which the dApp is operating.

- **Consistent API Usage:**  
  This approach maintains a consistent interface for retrieving account and network details, regardless of the connection mechanism. Even in WalletConnect-based wallets, `kadena_connect_v1` adheres to the same request/response structure, allowing dApps to operate uniformly.

- **Security and Domain Whitelisting:**  
  Wallets may leverage WalletConnect’s domain whitelisting and session persistence mechanisms. The `kadena_connect_v1` call then confirms the connection by returning verified account and network details, ensuring that the dApp receives contextually accurate data after the WalletConnect session is active.

## Backwards Compatibility

- **Legacy Methods:** Wallets **MAY** support deprecated connection methods alongside `kadena_connect_v1`. Legacy methods **MUST** be documented as deprecated and phased out over time.

- **Network Fallback:** Implementations **MUST** handle unsupported or invalid networkId values by returning an appropriate error.

## Security Considerations

- **Silent Mode Safeguards:**

  - Wallets **MUST** implement session expiration for silent reconnections.
  - Automatic reconnections **MUST** require prior explicit consent.

- **Phishing Protection:**
  - Wallets **MUST** display the requesting dApp’s domain during the initial connection and validate TLS certificates in web-based environments.
