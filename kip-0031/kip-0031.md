---
KIP: 0031
Title: Batch Signatures
Author: Greg Hale
Status: Draft
Type: Standard
Category: Spirekey
Created: 2024-07-30
---

## Abstract

Define a procedure for users to apply a signature to a batch of transactions.
This is important for WebAuthn, where a web client
requires a user interaction for access to the user's private key,
and the key may only
be used to sign one payload before requiring another user interaction.

This KIP will describe the a protocol for signing a batch of transactions,
and explain the server-side and client-side implementations.

Our protocol uses a Merkle Tree to quickly prove that a transaction is
an element of a batch, and a WebAuthn signature of the Merkle Root of
the batch to assert that the whole batch is is certified.

## Motivation

For complex features requiring multiple transactions, if we want
to use WebAuthn for authentication, but we don't want to spam users
with many biometric/2FA requests we need to be able to authenticate
multiple transactions with a single signature-creation event.

This constraint comes from the WebAuthn standard. WebAuthn does not give the client direct access to the userâ€™s private key. Instead, a WebAuthn Authenticator (such as a web browser or YubiKey) holds the private key as a secret and allows the client to sign payloads with it after some interaction with the user to prove their physical presence and identity. A payload goes from the client into the Authenticator, Authenticator waits for the user, and a signature comes out; the private key never goes to the client.

## Scope

WebAuthn: This proposal is limited to WebAuthn signatures, because other
wallet authentication methods have access to private keys and can simply
sign multiple transactions as they usually do.

Batches: a batch of transactions has no special meaning in Pact beyond the fact that the transactions were signed at the same time. For example there is no need to submit the transactions together in a SubmitBatch, nor any requirement that the transactions of a batch are executed in order. Future KIPs might conceivably introduce some cross-transaction dependencies,
but that would be a semantically different "batch" than the batches we are discussing in this KIP.

## Protocol

### Signature Creation

The client will use the WebAuthn assertion procedure in order to sign
a challenge on the user's behalf, with the user's private key. The `challenge``
is the Merkle Root of a Merkle Tree built from the list of transactions in the batch.

The Batch Signature for a particular transaction will also include a
Merkle Proof of that transaction's existence within the Merkle Tree.

A batch signature has this schema:

```
{
  "webAuthnSignature": {
    "signature": BASE64_URL,
    "clientDataJSON":  BASE64_URL,
    "authenticatorData": BASE64
  },
  "merkleProof": BASE64_URL
}
```

The transactions in a batch will all have the same `"webAuthnSignature"` but
different `"merkleProof".

### Batch signature encoding

The components above (WebAuthn signature + Merkle Proof) are called a "Batch Token".
The formatting of the components depends on the details of how the Merkle Tree
and Merkle Proof are constructed.

The following diagram shows how a list of transactions is assembled into a
Merkle Tree. The client and server must agree on the method of connecting
leafs with inner nodes, in order for the tree's root hash and the inclusion
proof to agree. Accidental mismatches in these areas will lead to an invalid
signature, not an error.

<img src="https://raw.githubusercontent.com/kadena-io/KIPs/kip-0031/kip-0031/merkle_tree.svg" width="600px" alt="Merkle Tree assebly diagram"/>

The tree is assembled by eagerly building balanced trees as far as possible,
and then adding balanced subtrees as far as possible. In the example above
with 6 leafs:

  - Leafs A and B are connected, creating first inner node 1.
  - Node 1 should not be connected to to Leaf C because this would
    form an unblalanced tree.
  - Nodes C and D are connected, creating Node 2.
  - Node 1 may be connected to Node 2 because this would form a balanced tree,
    with inner node 3.
  - Node 3 may not be connected to Leaf E because this would form an unbalanced tree.
  - Leafs E and F are connected, creating inner node 4.
  - We are out of leafs, so we may now connect remaining elements to make a tree
    that's as balanced as possible.
  - Nodes 3 and 4 are connected to create node 5.
  - All nodes connect transitively to a single inner node, so that node is
    the root node and we are done.

Leaf nodes and inner nodes each contain a Blake2b_256 hash. Leaf nodes contain
the hashes of transactions. Inner nodes contain the hash of the bytestring
concatenation of the contents of their children.

An inclusion proof for a transaction is constructed from a list of pairs of 
complementary node and side. For example, to prove the inclusion of A, we
would give: `[(B, Right), (2, Right), (4, Right)]`. When the server receives
transaction `A` and the proof, it will combine `A` with `B` to reconstruct
`1`, combine `1` with `2` to reconstruct `3`, and `3` with `4` to reconstruct
`5`. If `5` matches the signed root hash, then `1` must have been in the leafs
of the Merkle Tree.

Proofs are encoded by encoding each pair and concatenating the results. A pair
is encoded as a `0` byte for Left or `1`  byte for Right, immediately followed
by the bytestring digest of the Blake2b_256 hash.

### Signature verification

A `BatchToken` is a new variant of the existing `UserSig` enum type, so it is
handled within the existing `verifyUserSig` codepath.

To verify a `BatchToken` in the `sigs` field of a transaction, first decode the
Merkle Proof from the `merkleProof` field. Then evaluate the proof against the hash
of the transaction, this will produce a Root Hash.

The signature is valid if the Root Hash has been signed by the WebAuthn
assertion protocol, so we pass the Root Hash derived from the Merkle Proof
into our existing WebAuthn signature checking function. If this passes,
the transaction was part of the batch originally signed by the user, and
this signature is valid.
