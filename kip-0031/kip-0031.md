---
KIP: 0031
Title: Batch Signatures
Author: Greg Hale, Edmund Noble
Status: Draft
Type: Standard
Category: SpireKey
Created: 2024-07-30
---

# Abstract

This KIP defines a protocol for applying a single WebAuthN signature to a batch
of Pact transactions, such that each can be submitted independently to the
Kadena blockchain.

In the protocol, a user constructs a Merkle tree composed of the Pact
transactions to be signed, and signs the root of said Merkle tree using the
WebAuthN assertion ceremony. Then the user “signs” each transaction with a proof
that the transaction is included in the Merkle tree, in addition to the WebAuthN
signature for the Merkle root. At that point, each transaction can be submitted
individually to Chainweb.

# Motivation

Multi-chain and multi-step interactions with the Kadena blockchain involve
signing multiple transactions. As an example, cross-chain token transfers each
require two transactions: one to initiate the transfer on the source chain, and
one to finish the transfer on the target chain.

The WebAuthN standard does not give wallets direct access to the user’s private
key. Rather, the WebAuthN authenticator holds the private key and prompts the
user before signing data, and the private key cannot be accessed via the
WebAuthN interface. Often the private key cannot be extracted from the
authenticator at all, such as in the case of hardware authentication devices
like YubiKey. Because of this, signing multiple transactions entails prompting
the user multiple times, which is an unsatisfactory user experience. For
example: a single-step, 20-chain transaction would entail 20 prompts; a
two-step, 20-chain transaction would entail 40 prompts.

A protocol for signing a batch of transactions with a single signature would
allow wallets to prompt the user just a single time during these interactions,
with all of the details of each transaction displayed to the user at the same
time.

# Scope

This proposal is limited to WebAuthN signatures, because other wallet
authentication methods have access to private keys and can simply sign multiple
transactions individually.

A batch of transactions has no special meaning in Pact beyond the fact that the
transactions were signed at the same time. For example there is no need to
submit the transactions together in a single request to the Pact `/send`
endpoint, nor any requirement that the transactions of a batch are executed in
any order or on the same chain, nor any way to determine from Pact code whether
a transaction was signed as part of a batch.

# Usage

TBD

# Protocol

## Signature Creation

### Schema

The client will produce a batch of transactions which require signature. The
client then produces a Merkle tree from the batch of transactions, and we will
elaborate as to how this is done in this section. The client will then use the
WebAuthN assertion ceremony to sign the root of said Merkle tree on the user’s
behalf. See https://github.com/kadena-io/KIPs/pull/52 for more details as to
WebAuthN signatures as they relate to Pact transactions.

In place of an ordinary signature, the client will pair each transaction with a
pair of the Merkle root signature and the proof that the Merkle tree contains
that transaction.

A batch signature for a transaction has this schema:

```
{
  "webAuthnSignature": {
    "signature": BASE64_URL,
    "clientDataJSON":  BASE64_URL,
    "authenticatorData": BASE64
  },
  "merkleProof": BASE64_URL
}
```

These “batch signatures” can be included with transactions as ordinary
signatures, in the "sigs" field. The transactions in a batch will each have the
same "webAuthnSignature" but different "merkleProof".

### Merkle tree structure

> The client and server must agree on the structure and contents of the Merkle
> tree, in order for the tree's root hash and inclusion proof to agree.
> Accidental mismatches in these areas will lead to an invalid signature, not an
> error.

The Merkle tree is a binary tree assembled with the batch of transactions as the
leaves. We begin by eagerly building a forest of perfect binary trees from the
leaves, with each tree as large as possible, and then connecting them into a
final tree.

The following diagram shows the structure of a Merkle tree built from a list of
transactions with hashes `[A, B, C, D, E, F]`.

![Merkle tree assembly
diagram](https://raw.githubusercontent.com/kadena-io/KIPs/kip-0031/kip-0031/merkle_tree.svg
"(Top) The leaves and internal nodes of a Merkle Tree as encoded in the
merkle-log library. (Bottom) the order in which hashes of leaves and internal
nodes of a merkle-log Merkle tree are stored, for illustration purposes.")

In the example above, the process is:

- Leaves A and B are connected, creating the first inner node 1.
- Leaves C and D are connected, creating node 2.
- Node 1 is connected to node 2, creating node 3.
- Nodes E and F are connected, creating node 4.
- There are no remaining leaves at this point, so the remaining nodes are connected to form a tree.
- Nodes 3 and 4 are connected, creating node 5. Node 5 is the root of the resulting tree.

Each leaf node with a transaction hash `h` has the value `blake2b_256(0x00 <> h)`.
Each internal node with children having values `p` and `q` has the value
`blake2b_256(0x01 <> p <> q)`.

An inclusion proof for a transaction is constructed from a list of pairs of
complementary node and side, starting at the leaf node for the transaction and
ending at the root. For example, to prove the inclusion of `A` in the above
tree, we would give: `[(B, Right), (2, Right), (4, Right)]`.

Proofs are encoded by encoding each pair and concatenating the results. A pair
is encoded as a `0x00` for the Left side or `0x01` for the Right side,
immediately followed by the value of the node.


## Signature verification

To verify a batch signature in the `sigs` field of a transaction, first decode
the Merkle proof from the `merkleProof` field. Then evaluate the proof against
the hash of the transaction, to produce the Merkle root hash.

Using the earlier example Merkle tree, when the server receives transaction `A`
and its Merkle proof, it will combine `A` with `B` to reconstruct `1`, combine
`1` with `2` to reconstruct `3`, and combine `3` with `4` to reconstruct `5`. If
`5` matches the signed root hash, then `A` must have been in the leaves of the
Merkle tree.

> The signature is only valid if the root hash has been signed by the WebAuthN
> assertion protocol, so we pass the root hash derived from the Merkle proof
> into our existing WebAuthN signature checking function, along with the
> included webAuthnSignature field. If this passes, the transaction was part of
> the batch originally signed by the user, and the signature is valid.
